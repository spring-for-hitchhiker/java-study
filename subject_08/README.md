# 과제 04: 제어문

- [과제 04: 제어문](#과제-04-제어문)
  - [인터페이스란?](#인터페이스란)
    - [인터페이스와 추상 클래스의 차이점](#인터페이스와-추상-클래스의-차이점)
  - [인터페이스 정의하는 방법](#인터페이스-정의하는-방법)
  - [인터페이스 구현하는 방법](#인터페이스-구현하는-방법)
  - [인터페이스 레퍼런스를 통해 구현체를 사용하는 방법](#인터페이스-레퍼런스를-통해-구현체를-사용하는-방법)
  - [인터페이스 상속](#인터페이스-상속)
  - [인터페이스와 다형성](#인터페이스와-다형성)
    - [객체 지향](#객체-지향)
    - [역할과 책임](#역할과-책임)
  - [인터페이스의 장점](#인터페이스의-장점)
  - [인터페이스의 기본 메소드 (Default Method), 자바 8](#인터페이스의-기본-메소드-default-method-자바-8)
  - [인터페이스의 static 메소드, 자바 8](#인터페이스의-static-메소드-자바-8)
  - [함수형 인터페이스, 자바 8](#함수형-인터페이스-자바-8)
  - [인터페이스의 private 메소드, 자바 9](#인터페이스의-private-메소드-자바-9)

## 인터페이스란?

* 인터페이스는 `추상 메서드`의 집합이다.
  * 추가로 `상수`, `static 메서드`, `default 메서드`를 가질 수 있다.
* 인터페이스는 객체의 사용 방법을 정의한 `타입`이다.
  * 인터페이스를 메서드의 반환타입으로 지정하거나, 제네릭 타입으로 사용할 수 있다.

### 인터페이스와 추상 클래스의 차이점

* 인터페이스는 일종의 추상 클래스이며, 추상 클래스와 달리 추상 메소드만을 가진다.
    * 추상 클래스는 추상 메소드 외에도 일반 메소드, 멤버 변수, 생성자 등을 가질 수 있다.
* 인터페이스는 다중 상속이 가능한 반면, 추상 클래스는 단일 상속만 가능하다.
* 인터페이스와 추상 클래스는 모두 객체를 생성할 수 없다.
* 인터페이스는 구현(extends)을 통해 추상 메소드를 구현하며, 추상 클래스는 상속(extends)을 통해 추상 메소드를 구현한다.
* 인터페이스는 일반적으로 `-able`로 끝나는 형용사를 많이 사용한다.
    * 예를 들어, `Runnable`, `Comparable`, `Serializable` 등이 있다.
* 추상 클래스는 일반적으로 `Abstract-`로 시작하는 명사를 많이 사용한다.
    * 예를 들어, `AbstractList`, `AbstractMap`, `AbstractSet` 등이 있다.

|   구분   |  추상 클래스   |    인터페이스     |
|:------:|:---------:|:------------:|
|   상속   |    단일     |      다중      |
|   구현   | `extends` | `implements` |
|  생성자   |     O     |      X       |
| 멤버 변수  |     O     |      X       |
| 일반 메소드 |     O     |      X       |
| 추상 메소드 |     O     |      O       |
| 객체 생성  |     X     |      X       |
| 네이밍컨벤션 |  `-able`  | `Abstract-`  |

## 인터페이스 정의하는 방법

```java
public interface MyInterface {
    // 상수
    public static final int MY_CONSTANT = 42;
    int ANOTHER_CONSTANT = 100; // public static final 생략 가능

    // 추상 메소드
    public abstract void myMethod(int parameter);
    void anotherMethod(String parameter);  // public abstract 생략 가능
}
```

* 인터페이스에서 모든 `상수`는 `public static final`이고,
* 모든 `메서드`는 `public abstract`이다.
* 따라서 <U>생략 가능</U>하다.

## 인터페이스 구현하는 방법

```java
public class MyClass implements MyInterface {
    // MyInterface에 선언된 추상 메소드를 모두 구현해야 한다.
    @Override
    public void myMethod(int parameter) {
        // 구현 내용
    }

    @Override
    public void anotherMethod(String parameter) {
        // 구현 내용
    }
}
```

* 인터페이스를 구현하는 클래스는 인터페이스의 모든 추상 메소드를 구현해야 한다.
* 추상 메서드의 일부만 구현하는 경우, 해당 클래스는 abstract를 붙여 추상 클래스로 선언해야한다.

## 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법

```java
MyInterface myObject;
myObject = new MyClass();
```

* 인터페이스 타입의 변수는 인터페이스를 구현한 객체를 참조할 수 있다.
* 또한 인터페이스를 구현한 객체는 인터페이스 타입으로 변환 가능하다.
* 해당 인스턴스는 인터페이스에 선언된 메소드만을 사용할 수 있으며, 구현 객체의 메소드가 실행된다.
* 또한 구현 객체의 `멤버변수`를 사용할 수 없으며, 이를 사용하려면 구현 객체로 `타입 변환(캐스팅)`해야 한다.

## 인터페이스 상속

```java
public interface MyExtendedInterface extends MyInterface, AnotherInterface, AdditionalInterface {
    // MyInterface, AnotherInterface, AdditionalInterface에 선언된 추상 메소드를 모두 구현해야 한다.
}
```

* 인터페이스는 오직 인터페이스만 상속 가능하며, (`Object` 클래스도 X)
* 다중 상속이 가능하다.
    * 다중 상속이 문제가 되는 이유는 같은 선언부가 다른 구현을 갖기 떄문이다.  
      하지만 인터페이스는 구현부가 없기 때문에 같은 선언부가 중복되어도 충돌이 발생하지 않는다.
* 또한 상속 받은 인터페이스들의 추상 메소드는 모두 구현되어야 한다.

## 인터페이스와 다형성

* 인터페이스란 서로 다른 두 개의 시스템, 장치 사이에서 정보나 신호를 주고받는 경우의 접점이나 경계면이다.
  * 대표적인 인터페이스로 USB, HDMI, 블루투스 등이 있다.
* 다형성이란 어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질이다. 

### 객체 지향

* 객체 지향 프로그래밍은 현실 세계를 모델링하여 소프트웨어를 개발하는 방법이다.
* 현실 세계의 객체를 소프트웨어 객체로 설계하고, 객체들 간의 상호작용을 프로그래밍하는 방식이다.
* 객체 지향 프로그래밍의 특징은 `캡슐화`, `상속`, `추상화`, `다형성`이 있다.
* `캡슐화`는 객체의 상태를 나타내는 `속성`과 객체의 행동을 나타내는 `메소드`를 하나로 묶는 것이다.
* `상속`은 부모 클래스의 속성과 메소드를 자식 클래스가 물려받는 것이다.
* `추상화`는 객체들의 공통적인 특징을 파악하여 하나의 개념(클래스)로 다루는 것이다.
* `다형성`은 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것이다.
* 다형성은 `오버로딩`과 `오버라이딩`으로 구현된다.
  * `오버로딩`은 같은 이름의 메소드를 여러 개 정의하는 것이다.
  * `오버라이딩`은 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의하는 것이다.
  * 이를 통해 하나의 객체가 상황에 따라 다른 형태를 가질 수 있게 된다.

### 역할과 책임

객체 지향 프로그래밍에서 객체는 `역할`과 `책임`을 가진다.

* `역할`은 객체가 어떤 `행위`를 할 수 있는지를 나타낸다. → `인터페이스`
* `책임`은 객체가 `행위`를 어떻게 할지를 나타낸다. → `구현 클래스`

* 인터페이스는 객체의 `역할`과 `책임`을 분리한다.
  * 인터페이스는 객체의 사용 방법을 정의한 `타입`이다.
  * 인터페이스를 구현한 객체는 인터페이스 타입으로 변환 가능하다. → `다형성`
  * 인터페이스 타입으로 변환된 객체는 인터페이스에 선언된 메소드만을 사용할 수 있다. → `역할을 정의`
  * 인터페이스의 메서드를 호출하면 오버라이딩을 통해 구현된 객체의 메소드가 실행된다. → `책임을 수행`

## 인터페이스의 장점

인터페이스를 사용하면 개발 코드를 수정하지 않고, 사용하는 객체를 변경할 수 있다.  
기존에는 실행하는 객체를 변경하려면 개발 코드를 수정해야 했다.  
하지만 인터페이스를 사용하면 개발 코드와 객체가 느슨하게 결합되기 때문에 코드를 수정하지 않고도 객체를 변경할 수 있다는 장점을 가질 수 있다.

예를 들어, `MyInterface`를 구현한 `MyClass`를 사용하는 개발 코드가 있다고 가정하자.  
이때 `MyClass`를 `MyAnotherClass`로 변경하면 `MyClass`의 메소드를 호출하는 모든 코드를 수정해야 한다.  
하지만 `MyClass`를 호출하는 파일이 2~3000개라면 코드 한 줄 수정하는데 몇 시간이 걸릴 것이다.   
하지만 `MyInterface`를 사용하면 개발 코드를 수정하지 않고도 객체를 변경할 수 있다.  
(물론 DI 컨테이너를 사용하는 등 추가적인 작업이 필요하다.)

## 인터페이스의 기본 메소드 (Default Method), 자바 8

인터페이스는 `추상 메소드`와 `상수`만을 가질 수 있다.
하지만 자바 8에서는 하위 호환성을 위해 `default 메소드`를 추가할 수 있게 되었다.

`default` 메소드는 인터페이스에 선언되지만, 구현부를 갖는 인스턴스 메소드이다.
구현 클래스에서 해당 메서드를 정의하지 않아도 사용할 수 있으며, 재정의할 수도 있다.

공개된 라이브러리를 사용 중이라고 가정해보자.
해당 라이브러리의 인터페이스에 메서드가 추가된다면 해당 인터페이스를 사용하는 모든 코드를 수정해야 한다.  
하지만 `default` 메소드를 사용하면 해당 메소드를 구현하지 않아도 되기 때문에 하위 호환성을 유지할 수 있다.

## 인터페이스의 static 메소드, 자바 8

자바 8에서는 `defualt` 메서드와 별개로 `static` 메소드를 인터페이스에 추가할 수 있게 되었다.

`static` 메소드는 `default` 메서드와 마찬가지로 인터페이스에 선언되지만, 구현부를 갖는 클래스 메소드이다.

`static` 메서드는 인스턴스와 관계없는 독립적인 메서드이므로 인터페이스를 구현한 클래스에서 재정의할 수 없다.

`static` 메서드는 인터페이스를 구현한 클래스에서 직접 호출할 수 있으며,
인터페이스를 구현하지 않은 클래스에서도 인터페이스명을 통해 호출할 수 있다.

또한 `static` 메서드도 항상 `public`이며 생략할 수 있다. 

## 함수형 인터페이스, 자바 8

자바 8에서는 `함수형 프로그래밍`에서 람다 표현식을 지원하기 위해 함수형 인터페이스를 제공한다.

함수형 인터페이스(Functional Interface)는 `단 하나의 추상 메소드`만을 가지는 인터페이스이며,  
`@FunctionalInterface` 어노테이션을 통해 함수형 인터페이스임을 명시할 수 있다.

함수형 인터페이스를 사용하면 함수를 `1급 시민`처럼 다룰 수 있다.  
1급 시민 되면 변수에 `값으로 할당`하거나, `매개변수` 혹은 함수의 `반환값`으로 사용할 수 있다.

```java
// 함수형 인터페이스 선언
@FunctionalInterface
interface MyFunctionalInterface {
    void myMethod();
}

public class Main {
    public static void main(String[] args) {
        // 람다 표현식을 사용하여 함수형 인터페이스의 인스턴스 생성
        MyFunctionalInterface myFunc = () -> System.out.println("Hello, functional interface!");

        // 함수형 인터페이스의 메서드 호출
        myFunc.myMethod();
    }
}
```

## 인터페이스의 private 메소드, 자바 9

`private` 메서드는 해당 인터페이스 내에서만 사용되는 메서드이다.

주로 `default` 메서드에서만 사용되는 함수를 `private` 메서드로 분리하여 내부에서만 사용할 수 있도록 한다.

`static` 메서드도 `private`을 사용하여 정의할 수 있다.
