# 자바 스프링 7회차

## 람다식이란

메소드를 하나의 식으로 표현하는 것

람다식으로 표현하면 return 값이 없어지므로 람다식을 anonymous function(익명 함수) 이라고도 함

장점

- 코드를 간결하게 만들 수 있다
- 식에 개발자의 의도가 명확히 드러나 가독성이 향상된다
- 멀티쓰레드환경에서 용이하다
- 함수를 만드는 과정 없이 한번에 처리하기에 생산성이 높아진다

단점

- 람다로 인한 무명함수는 재사용이 불가능하다
    - 무명함수란?
        
        람다식은 무명함수를 만드는데 (int x) -> x + 1라는 add1함수를 add1$1, add1$2 이런식으로 여러개 만든다. 그래서 재사용이 불가능한데, 이를 변수, 데이터 구조에 할당하면 다시 쓸 수 있다.
        
- 디버깅이 많이 까다롭다
- 람다를 무분별하게 사용하면 코드가 클린하지 못하다(비슷한 함수 중복으로 생성 됨)
- 재귀로 만들 경우 부적합하다

## 람다식 사용법

```jsx
() -> {}
() -> 1
() -> { return 1; }
(int x) -> x+1
(x) -> x+1
 x -> x+1
(int x) -> { return x+1; }
 x -> { return x+1; }
(int x, int y) -> x+y
(x, y) -> x+y
(x, y) -> { return x+y; }
(String lam) -> lam.length()
lam -> lam.length()
(Thread lamT) -> { lamT.start(); }
lamT -> { lamT.start(); }
```

```java
(a, b) -> { return a > b ? a : b; }
OK // 중괄호에 묶은 람다는 block lambda라고 함.
(a, b) ->  return a > b ? a : b
NO // (return이 있을 경우 중괄호 생략 불가능 && 중괄호{}안에는 ; 써야함 && 코드가 한줄)
	 // 중괄호 없이 한줄이어야만 가능하다. expression lambda라고 함.
(a, b) -> a > b ? a : b
OK
```

```java
Thread thread = new Thread(new Runnable() {

    @Override
    public void run() {
          System.out.println("Start Thread");
          Thread.sleep(1000);
          System.out.println("End Thread");
   }
});
// 멀티쓰레드 환경 구현에서 run 메서드를 람다식으로 사용하면 편하다
Thread thread = new Thread(() -> {
          System.out.println("Start Thread");
          Thread.sleep(1000);
          System.out.println("End Thread");
});
```

## 함수형 인터페이스

함수형 인터페이스를 정의하고 @FunctionalI(대문자i임)nterface 애노테이션을 선언하면 컴파일러가 SAM(Single Abstract Method)인지 체크한다.

```java
@FunctinalInterface
interface MySum {
    public int sum(int a, int b);
}
FunctinalInterface 조건
1개의 메소드만 가지고 있어야함.
public static void main(String []args) {

    MySum func = (a, b) -> a + b;

    System.out.println(func.sum(10, 11));
}
// 결과 21
```

```java
public class Test {
    public static void main(String[] args) {
        // 람다식을 직접 사용
	      System.out.println(((IntBinaryOperator) (a, b) -> a + b).applyAsInt(1, 2));
        System.out.println(((IntBinaryOperator) (a, b) -> a + b).applyAsInt(3, 4));
        System.out.println(((IntBinaryOperator) (a, b) -> a + b).applyAsInt(5, 6));
    } // IntBinaryOperator 정수 두개 받아서 정수 두개 내보내는 인터페이스
}     // applyAsInt는 메서드 이름
			// 이러면 무명함수를 여러개 만들기도 하면서, 재사용도 불가능하다.

public class Test {
    public static void main(String[] args) {
				IntBinaryOperator add = (a, b) -> a + b;
				// 람다식을 캡처해서 사용
				System.out.println(add.applyAsInt(1, 2));
				System.out.println(add.applyAsInt(3, 4));
				System.out.println(add.applyAsInt(5, 6));
    } // 객체 명으로 람다식을 가둬놓았기 때문에, 이미 생겨있는 무명함수를 여러번 쓰는 개념
}
```

함수형 인터페이스

| 함수형 인터페이스 | 메서드 명 |
| --- | --- |
| java.lang.Runnable | void run(); |
| Supplier<T> | T get0; |
| Consumer<T> | void accept(T t); |
| Function<T, R> | R apply(T t); |
| Predicate<T> | boolean test(T t); |
| 입력값이 두개인 경우 | T, U = 참조 타입 || R = 리턴 타입 |
| BiConsumer<T, U> | void accept(T t, U u); |
| BiPredicate<T, U> | boolean test(T t, U u); |
| BiFunction<T, U, R> | R apply(T t, U u); |
| 동일한 타입을 리턴하는 경우 |  |
| UnaryOperator<T> | T apply(T t); |
| BinaryOperator<T> | T apply(T t1, T t2); |
| 이외에도 특정 컬렉션과 사용하는 경우 | 기본 리턴값을 사용하는 경우도 있다. |

## Variable Capture

variable capture란 람다식이나 익명 클래스 내부에서 외부변수를 사용하는 것을 말한다.

람다식에서 파라미터로 받은 대상이 외부 변수일 경우, 외부 변수는 final이거나 effectively final이어야한다.

effectively final이란?

final을 붙이지 않았지만, 초기화 된 이후 값이 변경되지 않은 변수를 말한다. 자바 컴파일러가 final로 간주해 주어서, 람다식에서 쓸 수 있게 해준다.

```java
public class Test {
    private int x = 10; // 인스턴스 변수(클래스 내부 선언)
		// 인스턴스 변수는 힙 메모리에 저장되므로, 람다식을 다 쓰고 난 후 지워진다.
    public void method() {
        Runnable r = () -> {
            x = 20; // 인스턴스 변수 x를 변경
            System.out.println(x);
        };
        r.run();
    }
}
public void method() {
    int num = 10; // 로컬 변수(메서드나 생성자, 블록에서 선언)

    Runnable r = () -> {
        System.out.println(num); // 로컬 변수 num을 사용
    }; 
		// num을 바꾸려 하면 안된다.
		// 람다식을 메서드의 인자로 전달하거나, 새로운 스레드에서 실행하는 경우
		// 람다식이 실행될때는 이 메서드가 종료되어 로컬 변수가 이미 메모리에 없을 수 있다.
		// 그렇기 때문에 final이나 effectively final이어야 람다식 내에 저장할 수 있다.
		// 람다식은 힙 영역에 생기는 객체이므로, 정확한 값을 저장해야하기 때문이다.
    r.run();
}
```

```java

public class Example {
    private String name = "Dave";

    public Supplier<String> getNameFunction() {
          return () -> this.name;
    }
}

public class Example {
private String name = "Dave";

    public Supplier<String> getNameFunction() {

        Supplier<String> getNamer = new Supplier<String>() {

            @Override
            public String get() {
								// return this.name;
                return Example.this.name;
            }
        };

        return getNamer;
    }
}
인터페이스를 쓸때 주의점으로는 this는 익명클래스 자체를 보기 때문에, 
어떤 익명 클래스인지 명시해주어야 한다.
```

## 메소드, 생성자 레퍼런스

정적 메소드 참조

```java
// 람다 표현식
ToIntFunction<String> stringToInt = (String s) -> Integer.parseInt(s);
// 메서드 참조
Function<String, Integer> stringToInteger = Integer::parseInt;
```

인스턴스 메서드 참조

```java
// 람다 표현식
BigPredicate<List<String>, String> contains = (list, element) -> list.contains(element);
// 메서드 참조
BigPredicate<List<String>, String> contains = List::contains;

// 람다 표현식
Function<String, Integer> stringLengthFunction = s -> s.length();
// 메서드 참조
Function<String, Integer> stringLengthFunction = String::length;
```

기존 객체의 인스턴드 메서드 참조

```java
// 람다 표현식
Predicate<String> startsWithNumber = (String s) -> this.startsWithNumber(s);
// 메서드 참조
Predicate<String> startsWithNumber = this::startsWithNumber;
```

생성자 참조 표현식

```java
// 람다 표현식
(인자로 들어갈 객체 -> new 클래스명(인자로 들어갈 객체))
// 생성자 참조
(클래스명::new);
```

기본 생성자 참조

```java
// 람다 표현식
Supplier<List<String>> listSupplier = () -> new ArrayList<>();
// 생성자 참조
Supplier<List<String>> listSupplier = ArrayList::new;
```

매개변수가 있는 생성자 참조

```java
// 람다 표현식
Function<String, Integer> integerCreator = s -> new Integer(s);
// 생성자 참조
Function<String, Integer> integerCreator = Integer::new;
```

배열 생성자 참조

```java
// 람다 표현식
Function<Integer, int[]> arrayCreator = size -> new int[size];
// 생성자 참조
Function<Integer, int[]> arrayCreator = int[]::new;
```